/**
 * @file LayoutInspectorView.java
 * @brief Class of the result view.
 * @author Sylvain DANGIN
 * @version 0.1
 * @date 6/17/2014
 * @copyright Copyright (c) 2014, Sylvain DANGIN\n
 * @par
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
 * @par
1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, 
this list of conditions and the followingdisclaimer in the documentation and/or
other materials provided with the distribution.
 * @par
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package layoutinspector.views;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import libs.Tuple;
import libs.XmlAttr;

import org.eclipse.jface.viewers.IStructuredContentProvider;
import org.eclipse.jface.viewers.ITreeContentProvider;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.jface.viewers.TreeViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.ui.ISharedImages;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.part.ViewPart;

/**
 * @class LayoutInspectorView
 * @brief Class of the result view.
 * @details Generated by Eclipse Wizard.
 */
public class LayoutInspectorView extends ViewPart
{
	/** @brief ID of the view. */
	public static final String ID = "fr.sdangin.layoutinspector.views.LayoutInspectorView";

	/** @brief Tree of the view. */
	private TreeViewer viewer;

	/**
	 * @class ViewContentProvider
	 * @brief Class for arrange data in the tree view.
	 * @details Generated by Eclipse Wizard.
	 */
	class ViewContentProvider implements IStructuredContentProvider, ITreeContentProvider
	{
		/** @brief Root of the view. */
		private TreeParent invisibleRoot;
		/** @brief Data of the tree. */
		private ArrayList<Tuple> data;
		
		/**
		 * @brief Constructor.
		 * @param data Data to show.
		 */
		public ViewContentProvider(ArrayList<Tuple> data)
		{
			this.data = data;
		}
		
		/**
		 * @brief Called when input is changed.
		 * @param v Viewer of the tree.
		 * @param oldInput Old input.
		 * @param newInput New input.
		 */
		public void inputChanged(Viewer v, Object oldInput, Object newInput)
		{
		}
		
		/**
		 * @brief Called by the viewer when it is disposed.
		 */
		public void dispose()
		{
		}
		
		/**
		 * @brief Get the tree for the view
		 * @param parent Element to display.
		 */
		public Object[] getElements(Object parent)
		{
			if (parent.equals(getViewSite()))
			{
				if (invisibleRoot==null)
					initialize();
				return getChildren(invisibleRoot);
			}
			return getChildren(parent);
		}
		
		/**
		 * @brief Get parent of the given child.
		 * @param child Child.
		 */
		public Object getParent(Object child)
		{
			if (child instanceof TreeObject)
			{
				return ((TreeObject)child).getParent();
			}
			return null;
		}
		
		/**
		 * @brief Get children of the given parent.
		 * @param parent Parent.
		 * @return Array of children.
		 */
		public Object [] getChildren(Object parent)
		{
			if (parent instanceof TreeParent)
			{
				return ((TreeParent)parent).getChildren();
			}
			return new Object[0];
		}
		
		/**
		 * @brief Test if parent has a children.
		 * @return True if parent has a children.
		 */
		public boolean hasChildren(Object parent)
		{
			if (parent instanceof TreeParent)
				return ((TreeParent)parent).hasChildren();
			return false;
		}

		/**
		 * @brief Initialize the tree from data.
		 */
		private void initialize()
		{
			TreeParent root = null;
			if (data == null)
			{
				root = new TreeParent("No results", 0);
			}
			else
			{
				root = new TreeParent("Results", 0);

				HashMap<Integer, TreeParent> hashMap = new HashMap<>();
				for (Tuple tuple : data)
				{
					if (tuple.count >= 2)
					{
						TreeParent node;
						int data = tuple.attrList.size();
						if (!hashMap.containsKey(data))
						{
							node = new TreeParent(data+" items", data);
							hashMap.put(data, node);
						}
						else
							node = hashMap.get(data);
						
						TreeParent resultNode = new TreeParent(tuple.count+" times", tuple.count);
						TreeParent attrsNode = new TreeParent("Attributes (XML)", 1);
						TreeParent filesNode = new TreeParent("Files", 0);
						for (XmlAttr attr : tuple.attrList)
						{
							TreeObject attrNode = new TreeObject(attr.key+"=\""+attr.value+"\"", 0);
							attrsNode.addChild(attrNode);
						}
						for (String file : tuple.files)
						{
							TreeObject fileNode = new TreeObject(file, 0);
							filesNode.addChild(fileNode);
						}
						resultNode.addChild(filesNode);
						resultNode.addChild(attrsNode);
						node.addChild(resultNode);
					}
				}
				for (Map.Entry<Integer, TreeParent> entry : hashMap.entrySet())
					root.addChild(entry.getValue());
			}
			invisibleRoot = new TreeParent("", 0);
			invisibleRoot.addChild(root);
		}
	}
	
	/**
	 * @class ViewLabelProvider
	 * @brief Get text and icon data of element.
	 * @details Generated by Eclipse Wizard.
	 */
	class ViewLabelProvider extends LabelProvider
	{
		/**
		 * @brief Get the text of the object.
		 * @param obj Object to show.
		 * @return Label of the object.
		 */
		public String getText(Object obj)
		{
			return obj.toString();
		}
		
		/**
		 * @brief Get image for an object.
		 * @param obj Object to show.
		 * @return Image of the object.
		 */
		public Image getImage(Object obj)
		{
			String imageKey = ISharedImages.IMG_OBJ_ELEMENT;
			if (obj instanceof TreeObject)
			{
				if (((TreeObject)obj).getParent().getName().equals("Files"))
					imageKey = ISharedImages.IMG_OBJ_FILE;
			}
			if (obj instanceof TreeParent)
			   imageKey = ISharedImages.IMG_OBJ_FOLDER;
			return PlatformUI.getWorkbench().getSharedImages().getImage(imageKey);
		}
	}

	/**
	 * The constructor.
	 */
	public LayoutInspectorView()
	{
	}

	/**
	 * @brief This is a callback that will allow us to create the viewer and initialize it.
	 */
	public void createPartControl(Composite parent)
	{
		viewer = new TreeViewer(parent, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL);
		viewer.setContentProvider(new ViewContentProvider(null));
		viewer.setLabelProvider(new ViewLabelProvider());
		viewer.setSorter(new NameSorter());
		viewer.setInput(getViewSite());		
		
		PlatformUI.getWorkbench().getHelpSystem().setHelp(viewer.getControl(), "fr.sdangin.layoutinspector.viewer");
	}

	/**
	 * @brief Passing the focus request to the viewer's control.
	 */
	public void setFocus() {
		viewer.getControl().setFocus();
	}

	/**
	 * @brief Set data of the tree.
	 * @param tuplesResult Results from LayoutInspector class.
	 */
	public void setData(ArrayList<Tuple> tuplesResult)
	{
		viewer.setContentProvider(new ViewContentProvider(tuplesResult));
		viewer.expandToLevel(2);
	}
}